---
layout: post
title:  "排序算法"
date:   2019-12-13 00:00:01
categories: [算法]
---
# 基本概念

  ## 排序的稳定性

  排序算法的稳定与否取决于该算法排序后会不会破坏初始顺序。

  举个例子，现在有一个列表，包含了学生的学号和他们的体重两个信息。现在要按体重为学生排序，相同体重的学生按学号排序。初始数据按学号有序排列。

  这种时候，就要求排序算法必须是稳定的，否则学号会乱掉。

  因此，排序的稳定性的作用就在于当初始顺序有意义时保持初始顺序不变。

  ## 算法的效率和程序的效率

  首先说明，这里的名词不严谨，是基于个人理解取的称呼。

  以快排为例，快排算法的时间复杂度大家都知道，O(nlogn)。然而在实际的程序中有的写法可能并不能达到这个水平，原因有很多，交换的方式、判断的次数等等都会影响实际效率。所以在实现算法时切记不是算法时间复杂度低程序就一定快，如果快排不用交换而用插入删除元素的方法实现一样会慢，还是要注意写法。
    
# 几种不同的排序方法

  ## 插入排序

  ### 直接插入排序

  #### 算法简述

  1. 取未排序序列的第一位，通过 **顺序查找**，插入已排序序列的对应位置

     如果已排序序列为空，直接将当前元素插入已排序序列
    
  2. 重复步骤1，直到所有元素被排序

  #### 性能和特点

  稳定性：稳定

  时间复杂度：O(n^2)

  空间复杂度：O(1)
  
  适用情况：初始序列基本有序、n 较小时，当初始序列过于无序或过长时时间复杂度过高

  ### 折半插入排序

  #### 算法简述

  因为直接插入排序使用顺序查找的方法，整体效率被拖慢，因此将搜索方式改为折半查找，由此提升效率

  1. 取未排序序列的第一位，通 **折半查找**，插入已排序序列的对应位置

     如果已排序序列为空，直接将当前元素插入已排序序列
    
  2. 重复步骤1，直到所有元素被排序

  #### 性能和特点
  
  稳定性：稳定

  时间复杂度：O(n^2)

  空间复杂度：O(1)

  适用情况：顺序储存结构，链式结构无法进行折半。初始序列无序、n 较大时表现更优

  ### 希尔排序

  #### 算法简述

  思路为局部处理序列，提高有序性，以此优化直接插入排序

  1. 取间隔 d1，所有间隔为d1的元素成一组，对每一组进行局部排序

  2. 取间隔 d2 < d1，重复步骤1，直到间隔为1，所有排序在一组内进行直接插入排序为止

  #### 性能和特点

  稳定性：不稳定，相同数字可能被分到不同的组从而被打乱顺序

  时间复杂度：取决于增量序列，目前比较快的增量序列有：

    O(n^3/2)的Hibbard增量：1,3,7,15...,2^k-1
    
    O(n^3/2)的knuth增量：1,4,13,40,...,(3^k - 1)/2

  空间复杂度：O(1)

  适用情况：n较大、初始序列无序。不适用于链式结构，因为局部排序后一条无序链表直接分裂成几条有序链表。

  ## 交换排序

  ### 冒泡排序

  #### 算法简述

  1. 顺序遍历序列，如果第 n 个元素大于第 n+1 个，交换两者

  2. 由于 1，序列末尾的元素最大。缩小序列规模至 1~n-1，重复步骤1，直到规模缩减至1

  #### 性能和特点

  稳定性：稳定

  时间复杂度：O(n^2)

  空间复杂度：O(1)

  适用范围：初始序列有序性强且长度较小。顺序结构或链式结构

  ### 快速排序

  #### 算法简述

  1. 取一个基点，记录其值

  2. 设指针 p 和 q，分别指向序列的头部和尾部

  3. 当 p 指向的元素小于基点且 p < q 时，右移 p；当 q 指向的元素大于基点且 p < q 时，左移 q

  4. 交换 p 和 q 指向的值，重复步骤 1-3，直到 p >= q

  5. 交换基点和 p 的值，使基点至于小于自己的数和大于自己的数之间

  6. 对序列 1-基点 和 基点-1 循环步骤1-5，直到子序列长度为1

  #### 性能和特点

  稳定性：不稳定，在分“比基点大”和“比基点小”时可能打乱顺序

  时间复杂度：O(nlog2(n))。
  
  基点选取方式不同实际效果也不同，合理的选取方式可以避免最坏情况，如“三者取中”原则：取序列首位、末位与中位的元素，取大小居中的作为基点

  如果基点是序列最大或最小值，则会进行过多次无效的排序，速度退化到简单排序水平

  空间复杂度：因为使用递归实现，需要空间储存一边的数据，故空间复杂度跟深度有关，为 O(n)

  适用范围：顺序结构。n 较大、序列无序时。

  ## 选择排序

  ### 简单选择排序

  #### 算法简述

  1. 顺序遍历序列，找到最小值，和序列首位元素交换

  2. 缩小序列规模，重复步骤1，直到所有元素都被排列

  #### 性能和特点

  稳定性：如果找到最小值后把它和首位交换，不稳定；如果找到最小值后把它插入到首位，稳定
  
  时间复杂度：O(n^2)

  空间复杂度：O(1)

  适用范围：n较小，移动次数较少

  ### 堆排序

  #### 算法简述

  1. 根据序列建树

  2. 调整树，使每一个节点的值都大于子节点的值 **待补充：调整方法**

  3. 交换根节点和最后一个节点

  4. 不计最后的节点，重复步骤 1-3，直到树只剩根节点

  #### 性能和特点

  稳定性：不稳定

  时间复杂度：O(nlog2(n))

  空间复杂度：O(1)

  适用范围：只适用于顺序结构，链式结构难以确定所谓“最后一个节点”。建堆时比较次数较多，所以数据规模较小时不是最好的选择，数据量大的时候更好

  ## 归并排序

  ### 2-路归并
  
  #### 算法简述

  1. 把序列看作多个长度为1的子序列

  2. 两两归并子序列：从两个序列中依次取值，选较小者放入新序列，若一个序列已经为空，将另一序列所有值全部放入新序列

  3. 重复操作 2，直到所有序列都被归并

  #### 性能和节点

  稳定性：稳定

  时间复杂度：O(nlog2(n))

  空间复杂度：O(n)

  适用范围：全部都可以

  ## 基数排序

  ### 链式基数排序

  #### 算法简述

  1. 取数字最低位为关键字

  2. 根据关键字将元素分类，一个关键字下的元素按原有序列顺序排列

  3. 按关键字顺序将所有元素排列

  4. 取更高一位数字为关键字，重复步骤 2-3，直到位数达到最高位

  #### 性能和特点

  稳定性：稳定

  时间复杂度：O(d(n+rd))，d指最高位位数，rd指关键字可取的值的数量（如果关键字为数字，则 rd=10），n 为序列长度
  
  空间复杂度：O(n+nd)

  适用范围：数据规模较小