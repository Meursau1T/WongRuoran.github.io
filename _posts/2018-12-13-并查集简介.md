---
layout: post
title: 并查集简介
category: [算法]
---
并查集可以用来高效解决多个集合之间的合并的问题，比如查找两个元素是否属于同一集合，将两个元素所在的集合合并等操作。

> r[a]是什么意思?

是元素a所属的集合的代表.

> 如果r[a] == a,这意味着什么?

a就是它所属集合的代表.

> 如果r[b] == a,是不是说b所属的集合的代表是a?

是的.这意味着什么呢?

> b不是它所属集合的代表.

完全正确!

> root(a)是什么意思?

找到a所属集合的代表.

> 我们怎么表示a所属集合的代表?

r[a]

> 如果r[a] == a,我们要做什么?

不用做什么,我们已经找到代表了.

> 如果r[a] != a呢?

说明a不是自己所属集合的代表,代表是别的元素.

> 我们怎么找到这个元素?

求root(r[a]).

> 为什么呢?

如同情报战中上下级,下级不知道最上层的人是谁,只能问自己的上级.所以a就去问r[a]了.

> 那root函数是什么样的呢?

```C
int root(int a){
  if(r[a] == a){
    return a;
  }
  return root(r[a]);
}
```

> 现在如何判断a和b两个元素是否属于同一集合呢?

看它们是否有同一个代表.如果答案是肯定的,那么`root(a) = root(b)`.

> 如果要合并a和b两个集合,是不是让他们的代表一样就可以了?

是的,我们可以`f[root(a)] = root(b)`,也就是让a的代表成为b的代表,这样他们就有了同样的代表,属于同一个集合.

> 直接修改代表有什么好处?

可以简化操作,不用处理集合里的元素.

> 上面的root函数已经够好了吗?

当然不是,我们中途询问了很多元素的代表,但最后只有a知道了它的代表.我们可以在询问的过程中记录下其它元素的请求,等找到代表后,把这个代表告诉所有元素.

> 这要怎么操作?

```C
int root(int a){
  if(r[a] == a){
    return a;
  }
  return r[a]=root(r[a]);
}
```

> 这就完了?

当然了,还要怎样.
