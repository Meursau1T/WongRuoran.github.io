---
layout: post
title: 并查集简介
category: [算法]
---
并查集可以用来高效解决多个集合之间的合并的问题，比如查找两个元素是否属于同一集合，将两个元素所在的集合合并等操作。

> root[a]是什么意思?

f是一个数组,root[a]是元素a所属的集合的代表.

> 如果root[a] == a,这意味着什么?

a就是它所属集合的代表.

> 如果root[b] == a,是不是说b所属的集合的代表是a?

是的.这意味着什么呢?

> b不是它所属集合的代表.

完全正确!

> find(a)是什么意思?

找到a所属集合的代表.

> 我们怎么表示a所属集合的代表?

root[a]

> 如果root[a] == a,我们要做什么?

不用做什么,我们已经找到代表了.

> 如果root[a] != a呢?

说明a不是自己所属集合的代表,代表是别的元素.

> 我们怎么找到这个元素?

求find(root[a]).

> 为什么呢?

如同情报战中上下级,下级不知道最上层的人是谁,只能问自己的上级.所以a就去问root[a]了.

> 那find函数是什么样的呢?

```C
int find(int a){
  if(root[a] == a){
    return a;
  }
  return find(root[a]);
}
```

> 现在如何判断a和b两个元素是否属于同一集合呢?

我们有函数connected,如果a和b的代表一样,返回1,否则返回0.

```C
int connected(int a,int b){
    if(find(a) == find(b)){
        return 1;
    }
    return 0;
}
```

> 如果要合并a和b两个集合,是不是让他们的代表一样就可以了?

是的,我们可以有union函数,让a的代表成为b的代表,这样他们就有了同样的代表,属于同一个集合.

```C
void union(int a,int b){
    root[find(a)] = find(b);
}
```

> 直接修改代表有什么好处?

可以简化操作,不用处理集合里的元素.

> 上面的find函数已经够好了吗?

当然不是,我们中途询问了很多元素的代表,但最后只有a知道了它的代表.我们可以在询问的过程中记录下其它元素的请求,等找到代表后,把这个代表告诉所有元素.

> 这要怎么操作?

```C
int find(int a){
  if(root[a] == a){
    return a;
  }
  return root[a]=find(root[a]);
}
```

> 这就完了?

当然了,还要怎样.
